class PaymentProcessor {  
+ processPayment(paymentInfo: PaymentInfo) : boolean  
+ connectTo3rdParty(paymentInfo: PaymentInfo) : boolean  
} 
} 
 
class Database {  
+ storeProductData(product: Product) : void  
+ retrieveProductData(productId: int) : Product  
+ storeCustomerData(customer: Customer) : void  
+ storeOrderHistory(order: Order) : void  
+ retrieveOrderHistory(customerId: int) : List<Order>  
} 
 
 
Storefront --> OrderProcessor : Uses  
OrderProcessor --> PaymentProcessor : Uses  
OrderProcessor --> InventoryManager : Uses  
OrderProcessor --> Database : Accesses  
InventoryManager --> Database : Accesses  
PaymentProcessor --> Database : Accesses   
@enduml  
 
 
Client -server architecture  
• Distributed system model which shows how data and processing is distributed across a 
range of components, but can also be implemented on a single computer.  
• Set of stand -alone servers which provide specific services such as printing, data 
management, etc.  
• Set of clients which call on these services.  
• Network which allows clients to access servers.  
 
A system that follows the client –server pattern is organized as a set of services and associated 
servers, and clients that access and use the services. The major com - ponents of this model are:  
1. A set of servers that offer services to other components. Examples of servers include print 
servers that offer printing services, file servers that offer file man - agement services, and a 
compile server, which offers programming language compilation servic es.  
2. A set of clients that call on the services offered by servers. There will normally be several 
instances of a client program executing concurrently on different computers.  
3. A network that allows the clients to access these services. Most client –server systems are 
implemented as distributed systems, connected using Internet protocols.  
Client –server architectures are usually thought of as distributed systems architectures but the logical 
model of independent services running on separate servers can be implemented on a single  
computer. Again, an important benefit is separation and independence. Services and servers can be  
changed without affecting other parts of the system.   (Score: 267.1599306211175)

---

To further clarify “Model -View -Controller ” architecture, let's explore a specific example . 
 
MVC (Model -View -Controller)  architecture example:  
Problem Description:  
A car rental company wants to develop a software system that will enable customers to rent cars online. 
Customers should be able to browse available cars, select a car to rent, and make a reservation. The 
system should keep track of the availability of cars, as well as the reservations made by customers.  
 
 Identify Use Cases  
• Browse available cars  
• Select a car to rent  
• Make a reservation  
 
UML class diagram  for above problem with MVC architecture : 
 @startuml  
  class CarRentalView {  
    +displayCar()  
    +displayReservationDetails()  
  } 
 
class CarRentalController {  
    -model: CarRentalModel  
    -view: CarRentalView  
    +searchCars()  
    +reserveCars()  
  } 
   
class CarRentalModel {  
    -customers: List<>  
    -cars: List<>  
    -reservations: List<>  
    +fetchCars()  
    +updateReservationDetails()  
  } 
CarRentalView -- CarRentalController: Request/Response  
CarRentalController --> CarRentalModel : Request Data  
CarRentalModel --> Database : Connection  
@enduml  
 
 
The Model  includes the  Customer , Car, and  Reservation  entities , along with methods for fetching  for cars 
and making reservations.  
The View  is represented by the CarRentalView, which defines methods for displaying cars and reservation 
details.  
The Controller  is represented by the CarRentalController class, which interacts with the Model and View to 
handle user actions and update the system state.  
 
 
 
 
  (Score: 267.26157244146714)

---

    } 
 
class BookManager {  
      + addBook(title: String, author: String, isbn: String)  
      + updateBook(bookId: Int)  
      + deleteBook(bookId: Int)  
    } 
 
    class UserManager {  
      + addUser(name: String, contactInfo: String)  
      + updateUser(userId: Int)  
      + deleteUser(userId: Int)  
    } 
 
    class TransactionManager {  
      + borrowBook(userId: Int, bookId: Int)  
      + returnBook(transactionId: Int)  
    } 
     
    LibraryApp --> BookManager  
    LibraryApp --> UserManager  
    LibraryApp --> TransactionManager  
} 
 
package "Server" {  
    class Book {  
      - bookId: Int  
      - title: String  
      - author: String  
      - isbn: String  
      - availabilityStatus: Boolean  
    } 
 
    class User {  
      - userId: Int  
      - name: String  
      - contactInfo: String  
    } 
 
    class Transaction {  
      - transactionId: Int  
      - bookId: Int  
      - userId: Int  
      - transactionDate: Date  
    } 
 
    interface Database {  
      + saveData(data: String)  
      + fetchData(query: String): String  
    } 
  (Score: 277.0573153777596)

---

 
• Application tier  
The application tier, also known as the logic tier or middle tier, is the heart of the application. In 
this tier, information that is collected in the presentation tier is processed - sometimes against 
other information in the data tier - using business lo gic, a specific set of business rules.  
 
• Data tier  
The data tier, sometimes called database tier, data access tier or back -end, is where the 
information that is processed by the application is stored and managed. This can be a  relational 
database system  or in a  NoSQL  Database server . 
 
Important info:  In a three -tier application, all communication goes through the application tier.  
• The Presentation Layer  should never directly access the  Data Layer . All requests go through 
the Application Layer . 
• Application Logic  should act as a middleman, containing all business rules.  
 
 
To further clarify “Three -tier” architecture, let's explore a specific example . 
Three -tier architecture example:  
Requirements:  
E-commerce websites  
• Presentation Layer:  The online storefront with product catalogs, shopping carts, and 
checkout interfaces.  
• Logic Layer:  Handles searching, order processing, inventory management, interfacing with 
3rd-party payment vendors, and business rules like discounts and promotions.  
• Data Layer:  Stores product information, customer data, order history, and financial 
transactions in a database.  
 
Class Diagram in PlantUML  for above problem with Three -tier architecture : 
@startuml  
class Storefront {  
- ProductCatalog : List<Product>  
- ShoppingCart : ShoppingCart  
- CheckoutInterface : Checkout  
+ viewProducts() : void  
+ addToCart(product: Product) : void  
+ proceedToCheckout() : void  
} 
package "Logic Layer" {  
class OrderProcessor {  
- paymentProcessor : PaymentProcessor  
- inventoryManager : InventoryManager  
+ processOrder(order: Order) : void  
+ applyDiscount(order: Order, discountCode: String) : float  
} 
 
class InventoryManager {  
+ checkStock(product: Product) : boolean  
+ updateStock(product: Product, quantity: int) : void  
} 
  (Score: 279.76212681157534)

---

Software Architecture Patterns and corresponding UML class diagrams  
 
The big picture  
Architectural design  is a process for identifying the sub -systems making up a system and the 
framework for sub -system control and communication. The output of this design process is a 
description of the software architecture. Architectural design is an early stage of the system design 
process. It represents the link between specification and design processes and is often carried out in 
parallel with some specificatio n activities. It involves identifying major system components and their 
communications.  
Software architectures can be designed at  two levels of abstraction : 
• Architecture in the small  is concerned with the architecture of individual programs. At 
this level, we are concerned with the way that an individual program is decomposed into 
components.   
• Architecture in the large  is concerned with the architecture of complex enterprise 
systems that include other systems, programs, and program components. These 
enterprise systems are distributed over different computers, which may be owned and 
managed by different companies.   
Three  advantages  of explicitly designing and documenting software architecture:  
• Stakeholder communication : Architecture may be used as a focus of discussion by 
system stakeholders.  
• System analysis : Well -documented architecture enables the analysis of whether the 
system can meet its non -functional requirements.  
• Large -scale reuse : The architecture may be reusable across a range of systems or entire 
lines of products.  
Software architecture is most often represented using simple, informal  block diagrams  showing 
entities and relationships.  Pros : simple, useful for communication with stakeholders, great for 
project planning.  Cons : lack of semantics, types of relationships between entities, visible properties 
of entities in the architecture.   
Uses  of architectural models:  
As a way of facilitating discussion about the system design   
A high -level architectural view of a system is useful for communication with system 
stakeholders and project planning because it is not cluttered with detail. Stakeholders can 
relate to it and understand an abstract view of the system. They can then discus s the system 
as a whole without being confused by detail.   
As a way of documenting an architecture that has been designed   
The aim here is to produce a complete system model that shows the different components 
in a system, their interfaces and their connections.  
 
 
Architectural design decisions  
Architectural design is a  creative process  so the process differs depending on the type of system 
being developed. However, a number of  common decisions  span all design processes and these 
decisions affect the non -functional characteristics of the system:   (Score: 283.93185164577756)